#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright (C) 2014-2016 Canonical Ltd.
# Author: Christopher Townsend <christopher.townsend@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import libertine.utils
import getpass
import os
import sys

from apt.debfile import DebPackage
from libertine import LibertineContainer
from libertine.ContainersConfig import ContainersConfig
from libertine.HostInfo import HostInfo


class LibertineContainerManager(object):

    def __init__(self):
        self.containers_config = ContainersConfig()
        self.host_info = HostInfo()

    def create(self, args):
        password = None

        if args.distro and not self.host_info.is_distro_valid(args.distro, args.force):
            print("Invalid distro %s" % args.distro, file=sys.stderr)
            sys.exit(1)

        if args.id and self.containers_config.container_exists(args.id):
            print("Container id \'%s\' is already used." % args.id, file=sys.stderr)
            sys.exit(1)
        elif not args.id:
            args.id = get_unique_container_id(distro)

        if not args.type:
            container_type = self.host_info.select_container_type_by_kernel()
        else:
            if args.type == 'lxc' and not self.host_info.has_lxc_support():
                print("System kernel does not support lxc type containers. "
                      "Please either use chroot or omit the -t option.")
                sys.exit(1)
            container_type = args.type

        if not args.distro:
            args.distro = self.host_info.get_host_distro_release()
        elif container_type == "chroot":
            host_distro = self.host_info.get_host_distro_release()

            if args.distro != host_distro:
                print("The container distribution needs to match the host ditribution for chroot"
                      " based containers. Please either use \'%s\' or omit the -d/--distro option."
                      % host_distro)
                sys.exit(1)

        if not args.name:
            args.name = "Ubuntu \'" + self.host_info.get_distro_codename(args.distro) + "\'"

        if container_type == "lxc":
            if args.password:
                password = args.password
            elif sys.stdin.isatty():
                print("Your user password is required for creating a Libertine container.")
                password = getpass.getpass()
            else:
                password = sys.stdin.readline().rstrip()

        self.containers_config.add_new_container(args.id, args.name, container_type, args.distro)

        multiarch = 'disabled'
        if args.multiarch == 'enable':
            multiarch = 'enabled'
        self.containers_config.update_container_multiarch_support(args.id, multiarch)

        container = LibertineContainer(args.id)
        self.containers_config.update_container_install_status(args.id, "installing")
        if not container.create_libertine_container(password, args.multiarch, args.verbosity):
            self.containers_config.delete_container(args.id)
            sys.exit(1)
        self.containers_config.update_container_install_status(args.id, "ready")

        libertine.utils.refresh_libertine_scope()

    def destroy_container_by_id(self, id):
        container = LibertineContainer(id)

        self.containers_config.update_container_install_status(id, "removing")
        container.destroy_libertine_container()
        self.containers_config.update_container_install_status(id, "removed")
        self.containers_config.delete_container(id)

    def destroy(self, args):
        args.id = self.containers_config.check_container_id(args.id)

        self.destroy_container_by_id(args.id)

        libertine.utils.refresh_libertine_scope()

    def install_package(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        is_debian_package = args.package.endswith('.deb')

        if is_debian_package:
            if os.path.exists(args.package):
                package = DebPackage(args.package).pkgname
            else:
                print("%s does not exist." % args.package)
                sys.exit(1)
        else:
            package = args.package

        if self.containers_config.package_exists(container_id, package):
            if not is_debian_package:
                print("Package \'%s\' is already installed." % package)
                sys.exit(1)
        else:
            self.containers_config.add_new_package(container_id, package)

        container = LibertineContainer(container_id)

        self.containers_config.update_package_install_status(container_id, package, "installing")
        if not container.install_package(args.package, args.verbosity, args.readline):
            self.containers_config.delete_package(container_id, package)
            sys.exit(1)

        self.containers_config.update_package_install_status(container_id, package, "installed")

        libertine.utils.refresh_libertine_scope()

    def remove_package_by_name(self, container_id, package_name, verbosity=1, readline=False):
        fallback_status = self.containers_config.get_package_install_status(container_id, package_name)
        self.containers_config.update_package_install_status(container_id, package_name, "removing")

        container = LibertineContainer(container_id)
        if not container.remove_package(package_name, verbosity, readline) and fallback_status == 'installed':
            self.containers_config.update_package_install_status(container_id, package_name, fallback_status)
            return False

        self.containers_config.update_package_install_status(container_id, package_name, "removed")
        self.containers_config.delete_package(container_id, package_name)

        return True

    def remove_package(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        if self.containers_config.get_package_install_status(container_id, args.package) != 'installed':
            print("Package \'%s\' is not installed." % args.package)
            sys.exit(1)

        if not self.remove_package_by_name(container_id, args.package, args.verbosity, args.readline):
            sys.exit(1)

        libertine.utils.refresh_libertine_scope()

    def search_cache(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        container = LibertineContainer(container_id)
        if container.search_package_cache(args.search_string) is not 0:
            sys.exit(1)

    def update(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        container = LibertineContainer(container_id)

        self.containers_config.update_container_install_status(container_id, "updating")
        if container.update_libertine_container(args.verbosity) is not 0:
            self.containers_config.update_container_install_status(container_id, "ready")
            sys.exit(1)

        self.containers_config.update_container_install_status(container_id, "ready")

    def list(self, args):
        containers = libertine.utils.Libertine.list_containers()
        for container in containers:
            print("%s" % container)

    def list_apps(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        container = LibertineContainer(container_id)
        print(container.list_app_launchers(use_json=args.json))

    def exec(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        container = LibertineContainer(container_id)

        if not container.exec_command(args.command):
            sys.exit(1)

    def delete_archive_by_name(self, container_id, archive_name):
        self.containers_config.update_archive_install_status(container_id, archive_name, 'removing')
        if LibertineContainer(container_id).configure_command('delete-archive', archive_name) is not 0:
            return False
        self.containers_config.delete_container_archive(container_id, archive_name)
        return True

    def configure(self, args):
        container_id = self.containers_config.check_container_id(args.id)

        container = LibertineContainer(container_id)

        if args.multiarch and self.host_info.get_host_architecture() == 'amd64':
            multiarch = 'disabled'
            if args.multiarch == 'enable':
                multiarch = 'enabled'

            current_multiarch = self.containers_config.get_container_multiarch_support(container_id)
            if current_multiarch == multiarch:
                print("i386 multiarch support is already %s" % multiarch)
                sys.exit(1)

            if container.configure_command('multiarch', args.multiarch) is not 0:
                sys.exit(1)

            self.containers_config.update_container_multiarch_support(container_id, multiarch)

        elif args.add_archive:
            if self.containers_config.archive_exists(container_id, args.add_archive):
                print("%s already added in container." % args.add_archive)
                sys.exit(1)

            self.containers_config.add_container_archive(container_id, args.add_archive)
            self.containers_config.update_archive_install_status(container_id, args.add_archive, 'installing')
            if container.configure_command('add-archive', args.add_archive) is not 0:
                self.containers_config.delete_container_archive(container_id, args.add_archive)
                sys.exit(1)

            self.containers_config.update_archive_install_status(container_id, args.add_archive, 'installed')

        elif args.delete_archive:
            if not self.containers_config.archive_exists(container_id, args.delete_archive):
                print("%s is not added in container." % args.delete_archive)
                sys.exit(1)

            if not self.delete_archive_by_name(container_id, args.delete_archive):
                sys.exit(1)

    def merge(self, args):
        self.containers_config.merge_container_config_files(args.file)

    def fix_integrity(self, args):
        for container in self.containers_config.container_list['containerList']:
            if 'installStatus' not in container or container['installStatus'] != 'ready':
                self.destroy_container_by_id(container['id'])
                continue
            LibertineContainer(container['id']).exec_command('dpkg --configure -a')

            for package in container['installedApps']:
                if package['appStatus'] != 'installed':
                    self.remove_package_by_name(container['id'], package['packageName'])

            if 'extraArchives' in container:
                for archive in container['extraArchives']:
                    if archive['archiveStatus'] != 'installed':
                        self.delete_archive_by_name(container['id'], archive['archiveName'])

    def set_default(self, args):
        if args.clear:
            self.containers_config.clear_default_container_id(True)
            sys.exit(0)

        container_id = self.containers_config.check_container_id(args.id)

        self.containers_config.set_default_container_id(container_id, True)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Legacy X application support for Unity 8")

    if not os.geteuid():
        print("Please do not run %s using sudo" % parser.prog)
        sys.exit(1)

    container_manager = LibertineContainerManager()

    parser.add_argument('-q', '--quiet',
                        action='store_const', dest='verbosity', const=0,
                        help=('do not print status updates on stdout'))
    parser.add_argument('-v', '--verbose',
                        action='store_const', dest='verbosity', const=2,
                        help=('extra verbose output'))
    subparsers = parser.add_subparsers(dest="subparser_name",
                                       title="subcommands",
                                       metavar='create, destroy, install-package, remove-package, search-cache, update, list, list-apps, configure')

    # Handle the create command and its options
    parser_create = subparsers.add_parser(
        'create',
        help=("Create a new Libertine container."))
    parser_create.add_argument(
        '-i', '--id',
        required=True,
        help=("Container identifier. Required."))
    parser_create.add_argument(
        '-t', '--type',
        help=("Type of Libertine container to create. Either 'lxc' or 'chroot'."))
    parser_create.add_argument(
        '-d', '--distro',
        help=("Ubuntu distro series to create."))
    parser_create.add_argument(
        '-n', '--name',
        help=("User friendly container name."))
    parser_create.add_argument(
        '--force', action='store_true',
        help=("Force the installation of the given valid Ubuntu distro even if "
              "it is no longer supported."))
    parser_create.add_argument(
        '-m', '--multiarch', action='store_true',
        help=("Add i386 support to amd64 Libertine containers.  This option has "
              "no effect when the Libertine container is i386."))
    parser_create.add_argument(
        '--password',
        help=("Pass in the user's password when creating an LXC container.  This "
              "is intended for testing only and is very insecure."))
    parser_create.set_defaults(func=container_manager.create)

    # Handle the destroy command and its options
    parser_destroy = subparsers.add_parser(
        'destroy',
        help=("Destroy any existing environment entirely."))
    parser_destroy.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_destroy.set_defaults(func=container_manager.destroy)

    # Handle the install-package command and its options
    parser_install = subparsers.add_parser(
        'install-package',
        help=("Install a package in the specified Libertine container."))
    parser_install.add_argument(
        '-p', '--package',
        required=True,
        help=("Name of package to install or full path to a Debian package. Required."))
    parser_install.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_install.add_argument(
        '-r', '--readline', action='store_true',
        help=("Readline mode. Use text-based frontend during debconf interactions."))
    parser_install.set_defaults(func=container_manager.install_package)

    # Handle the remove-package command and its options
    parser_remove = subparsers.add_parser(
        'remove-package',
        help=("Remove a package in the specified Libertine container."))
    parser_remove.add_argument(
        '-p', '--package',
        required=True,
        help=("Name of package to remove. Required."))
    parser_remove.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_remove.add_argument(
        '-r', '--readline', action='store_true',
        help=("Readline mode. Use text-based frontend during debconf interactions."))
    parser_remove.set_defaults(func=container_manager.remove_package)

    # Handle the search-cache command and its options
    parser_search = subparsers.add_parser(
        'search-cache',
        help=("Search for packages based on the search string in the specified Libertine container."))
    parser_search.add_argument(
        '-s', '--search-string',
        required=True,
        help=("String to search for in the package cache. Required."))
    parser_search.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_search.set_defaults(func=container_manager.search_cache)

    # Handle the update command and its options
    parser_update = subparsers.add_parser(
        'update',
        help=("Update the packages in the Libertine container."))
    parser_update.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_update.set_defaults(func=container_manager.update)

    # Handle the list command
    parser_list = subparsers.add_parser(
        "list",
        help=("List all Libertine containers."))
    parser_list.set_defaults(func=container_manager.list)

    # Handle the list-apps command and its options
    parser_list_apps = subparsers.add_parser(
        'list-apps',
        help=("List available app launchers in a container."))
    parser_list_apps.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_list_apps.add_argument(
        '-j', '--json',
        action='store_true',
        help=("use JSON output format."))
    parser_list_apps.set_defaults(func=container_manager.list_apps)

    # Handle the execute command and it's options
    parser_exec = subparsers.add_parser(
        'exec',
        add_help=False)
        #help=("Run an arbitrary command in the specified Libertine container."))
    parser_exec.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_exec.add_argument(
        '-c', '--command',
        help=("The command to run in the specified container."))
    parser_exec.set_defaults(func=container_manager.exec)

    # Handle the configure command and it's options
    parser_configure = subparsers.add_parser(
        'configure',
        help=("Configure various options in the specified Libertine container."))
    parser_configure.add_argument(
        '-i', '--id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_configure.add_argument(
        '-m', '--multiarch',
        choices=['enable', 'disable'],
        help=("Enables or disables i386 multiarch support for amd64 Libertine "
              "containers.   This option has no effect when the Libertine "
              "container is i386."))
    parser_configure.add_argument(
        '-a', '--add-archive',
        metavar='Archive name',
        help=("Adds an archive (PPA) in the specified Libertine container.  Needs to be "
              "in the form of \"ppa:user/ppa-name\"."))
    parser_configure.add_argument(
        '-d', '--delete-archive',
        metavar='Archive name',
        help=("Deletes an existing archive (PPA) in the specified Libertine container.  "
              "Needs to be in the form of \"ppa:user/ppa-name\"."))
    parser_configure.set_defaults(func=container_manager.configure)

    # Handle merging another ContainersConfig.json file into the main ContainersConfig.json file
    parser_merge = subparsers.add_parser(
        'merge-configs',
        add_help=False)
    parser_merge.add_argument(
        '-f', '--file',
        required=True)
    parser_merge.set_defaults(func=container_manager.merge)

    # Indiscriminately destroy containers, packages, and archives which are not fully installed
    parser_integrity = subparsers.add_parser(
        'fix-integrity',
        add_help=False)
    parser_integrity.set_defaults(func=container_manager.fix_integrity)

    # Set the default container in ContainersConfig
    parser_default = subparsers.add_parser(
        'set-default',
        help=("Set the default container."))
    parser_default.add_argument(
        '-i', '--id',
        metavar='Container id',
        help=("Container identifier.  Default container is used if omitted."))
    parser_default.add_argument(
        '-c', '--clear', action='store_true',
        help=("Clear the default container."))
    parser_default.set_defaults(func=container_manager.set_default)

    # Actually parse the args
    args = parser.parse_args()
    if args.verbosity is None:
        args.verbosity = 1

    if args.subparser_name == None:
        parser.print_help()
    else:
        args.func(args)
