#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright (C) 2015 Canonical Ltd.
# Author: Christopher Townsend <christopher.townsend@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import json
import libertine.utils
import lxc
import psutil
import shlex
import signal

from socket import *
from subprocess import DEVNULL

home_path = os.environ['HOME']


def get_container_type(container_id):
    container_type = ''

    with open(libertine.utils.get_libertine_database_file_path()) as fd:
        container_list = json.load(fd)
        fd.close()

    for container in container_list["containerList"]:
        if container["id"] == container_id:
            return container["type"]

    return ""


def set_dbus_session_socket_path():
    unique_id = os.environ['DISPLAY'].strip(':')

    if not os.path.exists(libertine.utils.get_libertine_runtime_dir()):
        os.makedirs(libertine.utils.get_libertine_runtime_dir())

    dbus_session_socket_path = (
        os.path.join(libertine.utils.get_libertine_runtime_dir(), 'host_dbus_session' + unique_id))

    os.environ['DBUS_SESSION_BUS_ADDRESS'] = "unix:path=" + dbus_session_socket_path

    return dbus_session_socket_path


def launch_libertine_session_bridge():
    libertine_session_bridge_cmd = "libertine-session-bridge " + set_dbus_session_socket_path()

    args = shlex.split(libertine_session_bridge_cmd)
    return psutil.Popen(args)


def build_proot_command(container_id):
    proot_cmd = '/usr/bin/proot'
    if not os.path.isfile(proot_cmd) or not os.access(proot_cmd, os.X_OK):
        raise RuntimeError('executable proot not found')
    proot_cmd += " -R " + libertine.utils.get_libertine_container_rootfs_path(container_id)

    # Bind-mount the host's locale(s)
    proot_cmd += " -b /usr/lib/locale"

    # Bind-mount extrausers on the phone
    if os.path.exists("/var/lib/extrausers"):
        proot_cmd += " -b /var/lib/extrausers"

    # Bind-mount common XDG direcotries
    bind_mounts = (
        " -b %s:%s"
        % (libertine.utils.get_libertine_container_userdata_dir_path(container_id), home_path)
    )

    xdg_user_dirs = ['Documents', 'Music', 'Pictures', 'Videos']
    for user_dir in xdg_user_dirs:
        user_dir_path = os.path.join(home_path, user_dir)
        bind_mounts += " -b %s:%s" % (user_dir_path, user_dir_path)

    proot_cmd += bind_mounts
    return proot_cmd


def launch_lxc_application(container_id, app_exec_line):
    container = lxc.Container(container_id, libertine.utils.get_libertine_containers_dir_path())

    libertine_lxc_mgr_sock = socket(AF_UNIX, SOCK_STREAM)
    libertine_lxc_mgr_sock.connect(libertine.utils.get_libertine_lxc_socket())

    # Tell libertine-lxc-manager that we are starting a new app
    message = "start " + container_id
    libertine_lxc_mgr_sock.send(message.encode())

    # Receive the reply from libertine-lxc-manager
    data = libertine_lxc_mgr_sock.recv(1024)

    if data.decode() == 'OK':
        if not container.wait("RUNNING", 10):
            print("Container failed to enter the RUNNING state")
            return

        if not container.get_ips(timeout=30):
            print("Not able to connect to the network.")
            return

    else:
        print("Failure detected from libertine-lxc-manager")
        return

    matchbox = container.attach(lxc.attach_run_command,
                                ['matchbox', '-use_titlebar', 'no'])

    # Setup pulse to work inside the container
    os.environ['PULSE_SERVER'] = libertine.utils.get_libertine_lxc_pulse_socket_path()

    container.attach_wait(lxc.attach_run_command, app_exec_line)

    os.kill(matchbox, signal.SIGTERM)
    os.waitpid(matchbox, 0)

    # Tell libertine-lxc-manager that the app has stopped.
    message = "stop " + container_id
    libertine_lxc_mgr_sock.send(message.encode())

    # Receive the reply from libertine-lxc-manager (ignore it for now). 
    data = libertine_lxc_mgr_sock.recv(1024)
    libertine_lxc_mgr_sock.close()


def launch_chroot_application(container_id, app_exec_line):
    proot_cmd = build_proot_command(container_id)

    args = shlex.split(proot_cmd)
    args.extend(['matchbox', '-use_titlebar', 'no'])
    matchbox = psutil.Popen(args)

    args = shlex.split(proot_cmd)
    args.extend(app_exec_line)
    psutil.Popen(args).wait()

    for child in matchbox.children():
        child.terminate()


if __name__ == '__main__':
    arg_parser = argparse.ArgumentParser(description='launch an application in a Libertine container')
    arg_parser.add_argument('container_id',
                            help='Libertine container ID')
    arg_parser.add_argument('app_exec_line', nargs=argparse.REMAINDER,
                            help='exec line')
    args = arg_parser.parse_args()

    container_type = get_container_type(args.container_id)

    session_bridge = launch_libertine_session_bridge()

    if container_type == "lxc":
        launch_lxc_application(args.container_id, args.app_exec_line)
    elif container_type == "chroot":
        launch_chroot_application(args.container_id, args.app_exec_line)

    session_bridge.terminate()
